}
plot(Rs , FDRs , xlab = "Number of Rejections", type = "l",
ylab = "False Discovery Rate", col = 4, lwd = 3)
lines(RBH,FDR,col=2,lwd=3)
legend("topright",legend=c("re-sampling FDR","t-test FDR"),lty=1,col=c(4,2),lwd=2)
# Chunk 34
p.values_unadj <- rep(NA,m)
p.value_BH<- rep(NA,m)
for (i in 1:m){
p.values_unadj[i] <- wilcox.test(x[y=="II",index[i]],x[y=="IV",index[i]],alternative="two.sided",paired = F,exact = F)$p.value
}
p.value_BH<- p.adjust(p.values_unadj,method = "BH")
RBH <- length(FDR)
for (j in 1:length(FDR)){
RBH[j] <- sum(p.value_BH<=FDR[j])
}
plot(Rs , FDRs , xlab = "Number of Rejections", type = "l",
ylab = "False Discovery Rate", col = 4, lwd = 3)
lines(RBH,FDR,col=2,lwd=3)
legend("topright",legend=c("re-sampling FDR","Mann-Whitney FDR"),lty=1,col=c(4,2),lwd=2)
# Chunk 35
wilcox.test(x[y=="II", 11], x[y=="IV", 11],paired = F)
# Chunk 36
wilcox.test(x[y=="II", 877], x[y=="IV", 877],paired = F)
RsBH <- length(FDRs)
for (j in 1:length(FDRs)){
RsBH[j] <- sum(p.values.resampleBH<=FDRs[j])
}
plot(Rs , FDRs , xlab = "Number of Rejections", type = "l",
ylab = "False Discovery Rate", col = 4, lwd = 3)
lines(RsBH,FDRs,col="orange",lwd=3,lty=2)
legend("topright",legend=c("plug-in re-sampling FDR","re-sampling BH"),lty=c(1,2),col=c("4","orange"),lwd=2)
par(mfrow=c(1,1))
hist(Tbs , breaks = 100, xlim = c(-4.2, 4.2), main = "",
xlab = "Null Distribution of Test Statistic", col = 7,ylim = c(0,400))
lines(seq(-4.2, 4.2, len = 1000),
dt(seq(-4.2, 4.2, len = 1000),
df = (n1 + n2 - 2)
) * 1000, col = 2, lwd = 3)
abline(v = TT, col = 4, lwd = 2)
text(TT + 0.5, 350, paste("T = ", round(TT, 4), sep = ""),
col = 4)
title("877th gene")
legend("topright",legend="Theoretical null distribution",lty=1,col=2,lwd=2)
FDR <- seq(0,1,by=0.01)
RBH <- length(FDR)
for (j in 1:length(FDR)){
RBH[j] <- sum(p.value_BH<=FDR[j])
}
plot(Rs , FDRs , xlab = "Number of Rejections", type = "l",
ylab = "False Discovery Rate", col = 4, lwd = 3)
lines(RBH,FDR,col=2,lwd=3)
legend("topright",legend=c("re-sampling FDR","t-test FDR"),lty=1,col=c(4,2),lwd=2)
install.packages("tidyverse")
installed.packages()
installed.packages("tidyverse")
install.packages("tidyverse")
summary(fit_KM)
head(aml)
library(survival)
library(survminer)
aml
head(aml,3)
Surv(aml$time,aml$status)
fit_KM <- survfit(Surv(time,status)~1,data=aml)
summary(fit_KM)
survminer::ggsurvplot(fit_KM)
fit_KM_by_x <- survfit(Surv(time,status)~x,data=aml)
survminer::ggsurvplot(fit_KM_by_x,conf.int=TRUE)
fit_log_rank <- survdiff(Surv(time,status)~x,data=aml)
## The function above returns a contingency table between expected and observed
## values against maintained and non-maintained values, as well as degrees of
## freedom and chi squared - with the corresponding probability.
survminer::ggsurvplot(fit_log_rank,conf.int=TRUE)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install()
## to make a sequence with a given start, stop and step
intro_seq <- seq(2,97,6)
## to make a random sequence of n numbers
# if not specified (mu=0,sd=1)
intro_rand <- rnorm(25,5,13)
is.numeric(intro_seq)
x_na <- NA
x_nan <- NaN
x_null <- NULL
!5
!0
## several functions can be used to check the data type
is.numeric(intro_seq)
is.character("Hallo welt!")
is.logical(FALSE)
is.infinite(2)
is.finite(Inf)
is.function(rnorm)
is.na(x_na)
is.nan(x_nan)
is.na(x_nan)
intro_rand > 30
intro_rand > 3
sum(intro_rand > 3)
len(intro_rand)
length(intro_rand)
sum(intro_rand > 3)
intro_seq[x > 3][x[x != 3] > 1]
intro_seq[intro_seq > 3][intro_seq[intro_seq != 3] > 1]
intro_rand[-(3:7)]
intro_rand[-(3:7)]
length(intro_rand[-(3:7)])
intro_vector <- c(127,321,354,764)
names(x) <- c("A","C","G","T")
intro_vector <- c(127,321,354,764)
names(intro_vector) <- c("A","C","G","T")
x_na <- NA
x_nan <- NaN
x_null <- NULL
!5
!0
intro_vector
intro_vector[c("C","G")]
intro_factor <- factor(c(1,2,3,1,2,1), levels=1:4)
na_matrix <- matrix(nrow=3,ncol=4)
intro_matrix <- matrix(1:12,nrow=3,ncol=4)
intro_matrix <- matrix(1:12,nrow=3,ncol=4)
rownames(intro_matrix) <- c("r1","r2","r3")
colnames(intro_matrix) <- c("c1","c2","c3","c4")
intro_matrix
intro_matrix[1:2,c("c1","c4")]
matrix(1:12,nrow=3,ncol=4,byrow=TRUE)
idvec <- c(1001,1002,1032,1321)
agevec <- c(46,62,71,55)
typevec <- c("melanoma","glioma","neuroblastoma","glioma")
stagevec <- c(3,4,2,3)
metasvec <- c(TRUE,FALSE,FALSE,FALSE)
patients <- data.frame(patient=idvec,age=agevec,
type=typevec,stage=stagevec,
metastases=metasvec)
rm(idvec,agevec,typevec,stagevec,metasvec)
patients
patients$age
class(patients$type)
patients$stage <- NULL
patients
dim(patients)
patients[order(patients$age),]
ordered_patients <- patients[order(patients$age),]
ordered_patients
library(survival)
aml
fit_cox <- coxph(Surv(time,status)~x,data = aml)
summary(fit_cox)
library(survival)
library(survminer)
aml
fit_cox <- coxph(Surv(time,status)~x,data = aml)
summary(fit_cox)
## The resulting "coef"0.9155 value is 'beta-hat' in the Cox formula and this
## means that since the hazard ratio "exp(coef)" is higher than 1, then the
ggsurvplot(survfit(Surv(time,status)~x,data=aml))
ggsurvplot(survfit(Surv(time,status)~x,data=aml,conf.int=TRUE))
survminer::ggsurvplot(fit_cox,conf.int=TRUE)
library(survival)
library(survminer)
aml
survminer::ggsurvplot(fit_cox,conf.int=TRUE)
ggsurvplot(survfit(Surv(time,status)~x,data=aml))
patients <- data.frame(patient=idvec, age=agevec,
type=typevec, stage=stagevec,
metastases=metasvec)
idvec <- c(1001, 1002, 1032, 1321)
agevec <- c(46, 62, 71, 55)
typevec <- c("melanoma", "glioma", "neuroblastoma", "glioma")
stagevec <- c(3, 4, 2, 3)
metasvec <- c(TRUE, FALSE, FALSE, FALSE)
patients <- data.frame(patient=idvec, age=agevec,
type=typevec, stage=stagevec,
metastases=metasvec)
class(patients)
class(patients)
patients$type <- NULL
patients
as.matrix(patients)
class(as.matrix(patients))
class(patients[1,1])
class(as.matrix(patients[1,1]))
class(as.matrix(patients[1,1]))
as.matrix(patients[1,1])
rm(list=ls())
idvec <- c(1001, 1002, 1032, 1321)
agevec <- c(46, 62, 71, 55)
typevec <- c("melanoma", "glioma", "neuroblastoma", "glioma")
stagevec <- c(3, 4, 2, 3)
metasvec <- c(TRUE, FALSE, FALSE, FALSE)
patients <- data.frame(patient=idvec, age=agevec,
type=typevec, stage=stagevec,
metastases=metasvec)
class(patients)
class(patients[1,1])
patients$type <- NULL
patients
class(as.matrix(patients))
as.matrix(patients[1,1])
class(as.matrix(patients[1,1]))
## EXERCISE 14
# Create the list mylist from the lecture (or any other list)
# - Try to better understand the difference between
#   > mylist[1]    and    > mylist[[1]]
# Use the command “class” to figure out what exactly you get back from these two ways of addressing list elements!
patient_list <- c(matrix(1:12, nrow=3, ncol=4),patients)
## EXERCISE 14
# Create the list mylist from the lecture (or any other list)
# - Try to better understand the difference between
#   > mylist[1]    and    > mylist[[1]]
# Use the command “class” to figure out what exactly you get back from these two ways of addressing list elements!
patient_list <- list(matrix(1:12, nrow=3, ncol=4),patients)
patient_list
patient_list[1]
patient_list[[1]]
patient_list[1]
class(patient_list[1])
patient_list[[1]]
class(patient_list[[1]])
number1 <- 30
number2 <- 20
operator <- readline(prompt="Please enter any ARITHMETIC OPERATOR You wish!: ")
switch(operator,
"+" = print(paste("Addition of two numbers is: ", number1 + number2)),
"-" = print(paste("Subtraction of two numbers is: ", number1 - number2)),
"*" = print(paste("Multiplication of two numbers is: ", number1 * number2)),
"^" = print(paste("Exponent of two numbers is: ", number1 ^ number2)),
"/" = print(paste("Division of two numbers is: ", number1 / number2)),
"%/%" = print(paste("Integer Division of two numbers is: ", number1 %/% number2)),
"%%" = print(paste("Division of two numbers is: ", number1 %% number2)),
print("default") # Default Statement
)
operator <- readline(prompt="Please enter any ARITHMETIC OPERATOR You wish!: ")
"+" = print(paste("Addition of two numbers is: ", number1 + number2)),
operator <- readline(prompt="Please enter any ARITHMETIC OPERATOR You wish!: ")
switch(operator,
"+" = print(paste("Addition of two numbers is: ", number1 + number2)),
"-" = print(paste("Subtraction of two numbers is: ", number1 - number2)),
"*" = print(paste("Multiplication of two numbers is: ", number1 * number2)),
"^" = print(paste("Exponent of two numbers is: ", number1 ^ number2)),
"/" = print(paste("Division of two numbers is: ", number1 / number2)),
"%/%" = print(paste("Integer Division of two numbers is: ", number1 %/% number2)),
"%%" = print(paste("Division of two numbers is: ", number1 %% number2)),
print("default") # Default Statement
)
xs <- c(1, 2, 3)
for (x in xs) {
xs <- c(xs, x * 2)
}
xs
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocCheck")
library(survival)
library(tidyverse)
library(survminer)
library(JM)
# Extending Cox model examples
# Time dependent covariates -----------------------------------------------
# Stanford Heart Transplant data related to survival of patients
# on the waiting list for the Stanford heart transplant program
# jasa: original data
# jasa1: processed data in long-format
head(dplyr::select(jasa,futime,fustat,transplant,surgery,age,wait.time))
jasa$transplant <- factor(jasa$transplant)
jasa1$age<- jasa1$age + 48 # Modify age as age+48 to have the same data of jasa dataset
jasa1 %>%
arrange(id) %>%
dplyr::select(id, start,stop,event,transplant,surgery,age) %>%
head()
# Fit a (time-independent) Cox PH model for transplant, surgery and age
tind_cox <- coxph(Surv(futime, fustat) ~ transplant + surgery + age, data=jasa)
summary(tind_cox)
# Having done a transplant decreases the hazard of a factor 0.18.
# Fit a Cox model with time-dependent transplant indicator
td_cox <- coxph(Surv(start, stop, event) ~ transplant + surgery + age, data=jasa1 )
summary(td_cox)
tibble::glimpse(veteran)
veteran$trt <- ifelse(veteran$trt==1,'standard','test')
veteran$trt <- as.factor(veteran$trt)
veteran$prior <- as.factor(veteran$prior)
fit_cox <- coxph(Surv(time, status) ~ trt + prior + karno, data=veteran)
summary(fit_cox)
zp <- cox.zph(fit_cox)
plot(zp,var="karno")
zp <- cox.zph(fit_cox)
abline(h=0,col='red')
plot(zp,var="karno")
plot(abline)
plot(zp)
zp <- cox.zph(fit_cox)
plot(zp,var="karno")
abline(h=0,col='red')
plot(zp)
vet2 <- survSplit(Surv(time, status) ~ ., data= veteran, cut=c(90, 180),
episode= "tgroup", id="id")
vet2[1:7, c("id", "tstart", "time", "status", "tgroup", "age", "karno")]
head(veteran)
# The first subject died at 72 days, his data is unchanged. The second and third subjects contribute
# time to each of the three intervals.
fit_cox_step <- coxph(Surv(tstart, time, status) ~ trt + prior + karno:strata(tgroup), data=vet2)
summary(fit_cox_step)
# Notice how the fact of having multiple rows with the same unit does not alter the estimates
# should we not consider time-dependent coefficients
fit_cox_long <- coxph(Surv(tstart, time, status) ~ trt + prior + karno, data=vet2)
fit_cox_long # this is the same model as fit_cox
fit_cox
zp2<-cox.zph(fit_cox_step)
zp2
fit_cox_long <- coxph(Surv(tstart, time, status) ~ trt + prior + karno:strata(tgroup), data=vet2)
fit_cox_long # this is the same model as fit_cox
fit_cox
fit_cox_cont <- coxph(Surv(time, status) ~ trt + prior + karno + tt(karno),
data=veteran, tt = function(x, t, ...) x * log(t+1))
summary(fit_cox_cont)
fit_cox_cont <- coxph(Surv(time, status) ~ trt + prior + karno + tt(karno),
data=veteran, tt = function(x, t, ...) x * log(t+1))
summary(fit_cox_cont)
dtimes <- sort(unique(with(veteran,time[status==1])))
length(dtimes)
vet_extended <- survSplit(Surv(time,status==1)~.,veteran,cut=dtimes)
vet_extended$ttk <- vet_extended$karno * log(vet_extended$time+1)
head(vet_extended)
head(veteran)
fit_cox_cont_manual <- coxph(Surv(tstart,time,event)~trt+prior+karno+ttk,data=vet_extended)
fit_cox_cont_manual
fit_cox_cont
install.packages("frailtypack")
install.pagkages("palmerpenguins")
install.packages("palmerpenguins")
BiocManager::install("Rsamtools")
BiocManager::install("GenomicRanges")
BiocManager::install("GenomicFeatures")
y = rnorm(20,0,10)
oldpar <- par(mfrow=c(3,2))
plot(y)
plot(y)
oldpar <- par(mfrow=c(3,2))
plot(y)
oldpar <- par(mfrow=c(3,2), mar=c(4, 4, 2, 1))
plot(y)
hist(y)
plot(-y)
hist(-y)
plot(y**2)
hist(y**2)
par(oldpar)
y = rnorm(20,0,10)
pdf("myfile.pdf")
oldpar <- par(mfrow=c(3,2), mar=c(4, 4, 2, 1))
plot(y)
hist(y)
plot(-y)
hist(-y)
plot(y**2)
hist(y**2)
par(oldpar)
dev.off()
if (!require(lme4)) {
cat("The 'lme4' package is not installed.\n")
} else {
cat("The 'lme4' package is installed.\n")
}
install.packages("optparse")
BiocManager::install(NOISeq)
BiocManager::install("NOISeq")
BiocManager::install("Repitools")
library(metafor)
library(metadat)
data("dat.linde2005")
# Let us consider Studies on the
# Effectiveness of St. John's Wort
# for Treating Depression
df <- na.omit(dat.linde2005[-c(1,12),c(1:4,13:17)]) # we use just a subset
View(df)
# HRSD: Hamilton Rating Scale for Depression
# ai is the number of responses in treatment group
# n1i is the number of patients in treatment group
# ci is the number of responses in placebo group
# n2i is the number of patients in placebo group
# Imagine that our Effect Size is the log Odds ratio:
# for the first study we would do
log_OR_1 <-
log((df$ai[1] / (df$n1i[1] - df$ai[1])) /
(df$ci[1] / (df$n2i[1] - df$ci[1])))
# With variance
var_log_OR_1 <- 1/df$ai[1]+
1/(df$n1i[1]-df$ai[1])+
1/df$ci[1]+
1/(df$n2i[1]-df$ci[1])
# With associated approximate CI
log_OR_1+c(-1,1)*qnorm(.975)*sqrt(var_log_OR_1)
# We can quickly compute it for all studies using the
# escalc function in the metafor pkg
df_enriched <- escalc(
measure = "OR",
ai = ai,
bi = n1i - ai,
ci = ci,
di = n2i - ci,
data = df,
append = TRUE
)
# In the metafor R package the function
# rma allows to model summary effect.
# Fixed Effect model ------------------------------------------------------
fit_FEM <- rma(
yi = yi,
vi = vi,
method = "FE",
data = df_enriched
)
# Theta is simply
coef(fit_FEM)
weighted.mean(x = df_enriched$yi,w = 1/df_enriched$vi)
# Forest plot
forest(fit_FEM,
slab = paste(df_enriched$study, df_enriched$year, sep = ", "))
# Or in the exp scale
forest(fit_FEM, slab = paste(df_enriched$study, df_enriched$year, sep = ", "),atransf = exp)
# Funnel plot
funnel(fit_FEM, main="Standard Error")
funnel(fit_FEM, yaxis="vi", main="Sampling Variance")
funnel(fit_FEM, yaxis="seinv", main="Inverse Standard Error")
funnel(fit_FEM, yaxis="vinv", main="Inverse Sampling Variance")
# Random effects model ----------------------------------------------------
fit_REM <- rma(yi =yi,vi = vi,method = "REML",data = df_enriched)  # the 'method' changes (from FE line 58)
fit_REM
# Theta is
coef(fit_REM)
weighted.mean(x = df_enriched$yi,
w = 1 / (fit_REM$tau2 + df_enriched$vi))
# Forest plot
forest(fit_REM, slab = paste(df_enriched$study, df_enriched$year, sep = ", "))
# Heterogeneity -----------------------------------------------------------
# we have already seen that the rma routine
# automatically provides the Q statistic
fit_FEM
# Q statistic manual calc
Q_man <- sum((1/df_enriched$vi)*
(df_enriched$yi-coef(fit_FEM))^2)
# I^2 manual calc
max(0,(Q_man-21)/Q_man)*100
# Meta regression ---------------------------------------------------------
# We can include one or more moderators
# (study-level variables) in the model
# that may account
# for at least part of the heterogeneity in the true effects.
# A MEM represent a Study-level regression for mean ES with:
# Y_i = log(OR_i) = beta^T x_i + u_i + e_i
# with u_i ~ N(0, tau^2) and e_i ~ N(0, V_i).
# The group variable corresponds
# to the variable used by Linde et al. (2005)
# to stratify their analyses and is coded as follows:
#
#  1 smaller trials restricted to major depression,
#
#  2 larger trials restricted to major depression,
#
# 3 smaller trials not restricted to major depression,
#
# 4 larger trials not restricted to major depression.
# Mixed-effects meta-regression
# model with stratification variable
fit_REM_mod <-
rma(
yi = yi,
vi = vi,
mods = ~ factor(group)-1,
method = "REML",
data = df_enriched
)
# predicted average risk ratio for each level of the stratification variable
predict(fit_REM_mod, newmods=diag(4), transf=exp, digits=2)
BiocManager::install("recount3")
BiocManager::install(c(
"recount", "GenomicRanges", "limma", "edgeR", "DESeq2",
"regionReport", "clusterProfiler", "org.Hs.eg.db", "gplots",
"derfinder", "GenomicState", "bumphunter", "derfinderPlot", "sessioninfo"
))
install.packages("Seurat")
devtools::install_github("thomasp85/patchwork")
install.packages("pandoc")
install.packages("Pandoc")
library(distConvert)
library(testthat)
library(distConvert)
ujtomiles(98731298)
uj_to_miles(7821789)
distConvert::uj_to_miles(8732198)
install.packages("limma")
BiocManager::install("limma")
install.packages("Seurat")
system.file(package='geneObjects')
install.packages("/geneObjects/geneObjects_1.0.0.tar.gz", repos = NULL, type = "source")
setwd("/Users/ncmbianchi/geneObjects")
install.packages("/Users/ncmbianchi/geneObjects/geneObjects_1.0.0.tar.gz", repos = NULL, type = "source")
library(geneObjects)
gene_structure <- GRanges("chr1", IRanges(5000, 6000), strand = "+")
library(geneObjects)
library(GenomicRanges)
library(geneObjects)
gene_structure <- GRanges("chr1", IRanges(5000, 6000), strand = "+")  # library(GenomicRanges) required
gene <- MicroRNAGene(ID = "ENSG000003", HUGO_symbol = "MIR00001", gene_name = "MicroRNA 1",description = "MicroRNA", gene_structure = gene_structure, microRNA_ID = "ENST000005", microRNA_seed_sequence = "UGAGGUAGUAGGUUGUAUGGUAG")
getID(gene)
setID(gene) <- "ENSG000103"
getID(gene)
lengthProduct(gene)
head(gene)
